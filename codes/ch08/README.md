## DP를 풀 때 생각해야 할 것들 ##
1. 부분문제 정의
2. 실제 정답의 위치 또는 계산법
3. 부분문제들을 푸는 순서, 완성해 나가는 방향(구현 또는 부분문제의 정의 방식, 논리 등)

어떤 문제를 푸는 알고리즘에 동적계획법을 적용할 때 고려해야하는 것들을 정리해보았다.  
<br>

LIS 문제를 푸는 동적계획법 알고리즘을 생각해보자. LIS문제를 푸는 데 있어 다음과 같은 부분문제 정의를 자주 볼 수 있다.  
```
lis(i): i번째 요소를 시작으로 하는 lis의 길이
lis(i) = 1 + max(lis(j)), a[i] < a[j]
```
LIS문제의 답은 0 <= i < n 에서 lis(i)의 최대값이다. 이런 부분문제 정의는 실제 문제에서 답이 되는 부분수열의 시작 위치에 대한 정보를 제공하지 않는다. 부분문제의 정의는 실제 문제의 답과 대응되지 않는 경우가 자주 있다. 따라서 부분문제의 정의와 실제의 답이 계산되는 방식 두 가지 모두를 고려하며 알고리즘을 작성해야 한다.  
<br>

부분문제가 구성되는 순서가 알고리즘 실행속도에 영향을 미칠 수도 있다. 다음의 문제를 예시로 생각해보자.
>n개의 노드로 이루어진 양방향 그래프에서 한 시행에 현재 노드에 연결된 인접 노드 중 무작위로 하나를 골라 이동할 수있다. 노드 v에서 시작해 이런 시행을 m번 반복하여 노드 w로 도착할 확률을 구하는 알고리즘을 작성하라. 노드 w는 여러 개가 될 수 있다.
첫 번째 알고리즘은 시작 노드 v로부터 이동하여 도착 노드가 w인 모든 경로들을 구하고, 해당 경로로 이동할 확률들을 누적하는 방식으로부터 아이디어를 얻었다. 이에 동적계획법을 적용해 조금 더 빠른 시간에 동작하도록 했다. 부분문제의 정의는 다음과 같다.
```
prob(i, x): 현재까지 i번 이동해 x에 도착했을 때, 마지막에 w에 도착할 조건부 확률
prob(i, x) = sigma(prob(i + 1, adj) / deg(x)), prob(m, x) = 1 if x == w else 0
```
이때 총 부분문제의 개수는 O(nm)이고 각 부분문제를 푸는 데 평균적으로 O(n)이 걸린다하면 실제 문제의 답인 prob(0, v)를 계산하는 데 시간복잡도 O(mn^2)의 시간이 걸린다.  
다른 알고리즘은 비슷한 아이디어를 적용했지만 경로를 완성해나가는 방식을 거꾸로하여 부분문제를 정의했다.
```
prob(i, x): i번 이동해 v에 도착할 확률
prob(i, x) = sigma(prob(i - 1, adj) / deg(adj)), prob(0, x) = 1 if x == v else 0
```
이때 실제 문제의 답은 prob(m, w)가 되면 첫 번째 알고리즘과 동일한 시간복잡도를 가진다.  
하지만 첫 번째 알고리즘의 경우는 도착 노드가 달라지면 전체 계산을 모두 다시 진행해야 한다. 두 번째 알고리즘은 다른 도착 노드에 대해서도 이미 계산된 결과를 이용해 답을 구할 수 있다. 따라서 만약 문제에서 요구하는 노드 w의 개수가 k개였다면 첫 번째 알고리즘으로 문제를 모두 푸는 데 걸리는 시간의 시간복잡도는 O(kmn^2)인 반면 두 번째 알고리즘으로 문제를 모두 푸는 데 걸리는 시간의 시간복잡도는 O(mn^2)이다.